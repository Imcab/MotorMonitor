{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Source code in our Github</p>"},{"location":"#welcome-to-motor-monitor-docs","title":"Welcome to Motor Monitor docs!","text":"<p>Motor Monitor, developed by team #3472 is a class that provides security methods to all the motors in FRC.</p> <p>With Motor Monitor, the motors now will react to high spike voltages, high current or low battery voltage by the robot, preserving the motor and safe it for an damage. Motor Monitor provides a variety of security protocols according to what fits best for every team.</p> <p>Download file</p>"},{"location":"#v102","title":"V1.0.2","text":""},{"location":"#installation-guide","title":"Installation Guide","text":"<p>Supported Languajes</p> <p>This file is only made in Java, C++ or other languajes are NOT supported</p> <p>Motor Monitor is a file that you can add to your robot package. Click on the download button or here, move the downloaded file to your robot's directory and Thats it!</p> <p>We recommend creating a folder in your project for more organization, in our case we create the folder <code>\\Utils</code> to save the motor monitor and other utils we made through the season. You should get something like this:</p> <p><code>\\java\\frc\\robot\\Utils\\MotorMonitor.java</code></p> <p></p> <p>Now that you get the file and place it in the ideal location we can start to use it through the <code>MotorMonitor</code> class</p>"},{"location":"page1/","title":"Getting Started","text":""},{"location":"page1/#motor-monitor-class","title":"Motor Monitor Class","text":""},{"location":"page1/#creating-a-new-motormonitor","title":"Creating a new MotorMonitor","text":"<p>Through the <code>MotorMonitor</code> class we can perform various types of actions but first, we will initialize a new Motor Monitor for our motor</p> <p>To create a <code>MotorMonitor</code> we will need the next parameters:</p> <p></p> <ul> <li>Power Distribution System (PDP)</li> <li>The pdp's channel to check the motor's current</li> </ul> <p>We can do it with the <code>PowerDristibution</code> from wpilibj</p> <p>Info</p> <p>You need to pass to the constructor the pdp's channel that the motor is connected  NOT the CAN ID of the motor</p> RevCTRE <pre><code>PowerDistribution pdp = new PowerDistribution(0, ModuleType.kRev) //Example Rev's pdp with ID 0\n\nint m_channel = 1; //Motor's pdp channel\n</code></pre> <pre><code>PowerDistribution pdp = new PowerDistribution(0, ModuleType.kCTRE) //Example CTRE pdp with ID 0\n\nint m_channel = 1; //Motor's pdp channel\n</code></pre> <p>With the pdp created, we can now create our first MotorMonitor like this:</p> <pre><code>//Create a new MotorMonitor with the pdp we created above\nMotorMonitor m_monitor = new MotorMonitor(pdp, m_channel);\n</code></pre>"},{"location":"page1/#set-up","title":"Set up","text":"<p>Great! we have our MotorMonitor created, now we need to create the motors we will use. In our case we will create a brushless motor with the <code>CANSparkMax</code> class from REV Robotics (you can install it from here), other motors should work the same</p> <pre><code>//Creating the motor in CAN ID 1\nCANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless)\n</code></pre> <p>We will also create a Joystick to interact with our motor, we'll use the <code>XboxController</code> class that wpilibj provides us. At the end, we should have something like this:</p> <pre><code>PowerDistribution pdp = new PowerDistribution(0, ModuleType.kRev) //Example Rev's pdp with ID 0\n\nint m_channel = 1; //Motor's pdp channel\n\n//Create a new MotorMonitor with the pdp we created above\nMotorMonitor m_monitor = new MotorMonitor(pdp, m_channel);\n\n//Creating the motor in CAN ID 1\nCANSparkMax m_motor = new CANSparkMax(1, MotorType.kBrushless)\n\n//Creates a XboxController with USB port 0\nXboxController controller = new XboxController(0);\n</code></pre>"},{"location":"page1/#creating-multiple-instances","title":"Creating Multiple instances","text":"<p>Don't create new PDP's</p> <p>You DON'T need to create a new pdp for each <code>MotorMonitor</code> you create, you should use the same pdp for ALL instances of the <code>MotorMonitor</code> you will use</p> <p>You can create as many <code>MotorMonitor</code> as you want for your mechanisms:</p> <pre><code>MotorMonitor IntakeMonitor = new MotorMonitor(pdp, intake_channel);\n\nMotorMonitor FlyWheelMonitor = new MotorMonitor(pdp, fly_channel);\n\nMotorMonitor ElevatorMonitor = new MotorMonitor(pdp, elevator_channel);\n</code></pre> <p>Warning</p> <p>You CAN'T create multiple <code>MotorMonitor</code> for a single motor. Each motor will only have an UNIC <code>MotorMonitor</code> for itself</p>"},{"location":"page1/#next-steps","title":"Next Steps","text":"<p>Now that we have our environment set we can proceed to configure our MotorMonitor</p>"},{"location":"page2/","title":"Configuring the MotorMonitor","text":"<p>For the correct use of the MotorMonitor, we need to configure it to our preferences and safety measurements, we can do this through the <code>MonitorConfig</code> class</p>"},{"location":"page2/#monitorconfig-class","title":"MonitorConfig class","text":"<p>The <code>MonitorConfig</code> class is constructed by this four parameters:</p> <ul> <li>Protocol: how the motor will react to risk conditions</li> <li>currentThreshold: the MAX current the motor should take</li> <li>batteryThreshold: the MINUMUM battery voltage that triggers the protocol</li> <li>maxCurrentChangeRate: the MAX current change rate, this to predict if the motor is experiencing a rapid current increase</li> </ul>"},{"location":"page2/#protocol","title":"Protocol","text":"<p>We can access to the list of all the protocols through the <code>MotorProtocol</code> like this:</p> <pre><code>MotorProtocol.k&lt;the protocols&gt;;\n\n//Example\nMotorProtocol.kSmartCooldown;\n</code></pre> <p>The list of all the protocols can be found here:</p> <p>Info</p> <p>A protocol will be triggered if the motor reports: High current or Low Battery of the robot</p> <ul> <li>kNone: safety functions disabled</li> <li>kShutdown: shutdowns the motor until the current is safe</li> <li>kProportionalReduction: Reduce the given output proportionally</li> <li>kBatterySaver: Triggered if the battery voltage is low, reducing the given output by half</li> <li>kCooldown: The motor enters in a cooldown mode</li> <li>mpPredictiveOverload: If the motor's current increases rapidly, reduce the given output</li> <li>kVoltageSpikeProtection: Analyse if the motor is taking a voltage drop, reducing it's output</li> <li>kSmartCooldown: Predict if the motor needs to cooldown and reduce the given output</li> <li>kDynamicPowerLimit: Limits the output based on the pdp's total current</li> </ul>"},{"location":"page2/#default-values","title":"Default values","text":"<p>If you don't know very well how to tune the <code>MonitorConfig</code>, the <code>MotorMonitor</code> class counts with static default values that you can use from the configuration</p> <pre><code>    //Default values\n\n    double MaxCurrent = MotorMonitor.DEFAULT_CURRENT_THRESHOLD;\n    double MinBattery = MotorMonitor.LOW_BATTERY_THRESHOLD;\n    double MaxCharge = MotorMonitor.DEFAULT_MAXCURRENTCHANGE;\n</code></pre>"},{"location":"page2/#creating-a-monitorconfig","title":"Creating a MonitorConfig","text":"<p>Now that we decide our settings, we'll create a new <code>MonitorConfig</code> saving it through a <code>var</code> or a <code>MonitorConfig</code> as you prefer:</p> varMonitorConfig <pre><code>//Empty Configuration\nvar config = new MonitorConfig(null,0,0,0);\n</code></pre> <pre><code>//Empty Configuration\nMonitorConfig config = new MonitorConfig(null,0,0,0);\n</code></pre> <p>Next, we need to pass our values to the constructor like this:</p> <pre><code>    //Proportional Reduction with default values\n    double MaxCurrent = MotorMonitor.DEFAULT_CURRENT_THRESHOLD;\n    double MinBattery = MotorMonitor.LOW_BATTERY_THRESHOLD;\n    double MaxCharge = MotorMonitor.DEFAULT_MAXCURRENTCHANGE;\n\n    var config = new MonitorConfig(MotorProtocol.kProportionalReduction,MaxCurrent,MinBattery,MaxCharge);\n</code></pre> <p>Tip</p> <p>You can use the same config to apply it to different <code>MotorMonitor</code> instances</p>"},{"location":"page2/#applying-the-configuration","title":"Applying the configuration","text":"<p>Finally we need to apply our changes to the <code>MotorMonitor</code> we created, we can do this with the <code>applyConfiguration(configuration)</code> method or manually through every specified method</p> <pre><code>    //Creation of the pdp and other environments [...]\n\n    //Monitor\n    MotorMonitor m_monitor = new MotorMonitor(pdp, m_channel);\n\n    //Proportional Reduction with default values\n    double MaxCurrent = MotorMonitor.DEFAULT_CURRENT_THRESHOLD;\n    double MinBattery = MotorMonitor.LOW_BATTERY_THRESHOLD;\n    double MaxCharge = MotorMonitor.DEFAULT_MAXCURRENTCHANGE;\n\n    //Creating the configuration\n    var config = new MonitorConfig(MotorProtocol.kProportionalReduction,MaxCurrent,MinBattery,MaxCharge);\n\n    //Applying it\n    m_monitor.applyConfiguration(config);\n</code></pre> <p>Manually method works too:</p> <pre><code>    //Creation of the pdp and other environments [...]\n\n    //Monitor\n    MotorMonitor m_monitor = new MotorMonitor(pdp, m_channel);\n\n    //Proportional Reduction with default values\n    double MaxCurrent = MotorMonitor.DEFAULT_CURRENT_THRESHOLD;\n    double MinBattery = MotorMonitor.LOW_BATTERY_THRESHOLD;\n    double MaxCharge = MotorMonitor.DEFAULT_MAXCURRENTCHANGE;\n\n    //Applying it manually\n\n    m_monitor.setMotorProtocoll(MotorProtocol.kProportionalReduction);\n\n    m_monitor.adjustCurrentThreshold(MaxCurrent);\n\n    m_monitor.setBatteryThreshold(MinBattery);\n\n    m_monitor.setMaxCurrentChangeRate(MaxCharge);\n</code></pre> <p>Both methods for applying the desired configuration should work. If we finished applying the config, we can finally start to start using our MotorMonitor</p>"},{"location":"page3/","title":"Using Motor Monitor -Logging","text":"<p><code>MotorMonitor</code> provides a lot of methods to provide safety and logging to know what is actually happening to the motor</p>"},{"location":"page3/#logging","title":"Logging","text":"<p>We can obtain information fields for feedback with <code>MotorMonitor</code> to keep an observation of each motor performance through the match</p>"},{"location":"page3/#state","title":"State","text":"<p>We can log the state of the <code>MotorMonitor</code> by two methods:</p> <ul> <li> <p>void <code>monitorMotor()</code> sends alert to the driver station reporting anomalies in the motor</p> </li> <li> <p>string <code>getMotorState()</code> returns the \"state\" (alert) of the motor for you to use for display</p> </li> </ul> <p>Info</p> <p>All this methods should be called periodically, every X seconds or being triggered for optimization</p> <pre><code>    m_monitor.monitorMotor(); //Logs the state of the motor\n\n    String motor1State = m_monitor.getMotorState();\n\n    SmartDashboard.putString(\"Motor 1 state:\", motor1State); //Logs the state and shows it to your Dashboard\n</code></pre> <p>The alert it will show is the following:</p> <pre><code>\"ALERT! MOTOR IN CHANNEL[ \"+ channel + \"] IS OVERCHARGED\"\n</code></pre> <p>If you're using the <code>getMotorState()</code> method, it will show this text if there's no errors:</p> <pre><code>\"Current State: Good (Motor in channel[ \"+ channel + \"])\"\n</code></pre>"},{"location":"page3/#individual-fields","title":"Individual Fields","text":"<p>Additionally we can log more detailed information of the motor</p> <pre><code>    m_monitor.monitorMotor(); //Logs the state of the motor\n\n    String motor1State = m_monitor.getMotorState();\n\n    double motor1Current = m_monitor.getMotorCurrent();\n\n    boolean isOverCharged = m_monitor.isOverCharged(0); //Checks if the motor is OverCharged with additional margin of 0\n\n    SmartDashboard.putString(\"Motor 1 state:\", motor1State); //Logs the state and shows it to your Dashboard\n\n    SmartDashboard.putNumber(\"Motor 1 current:\", motor1Current); //Logs the Current\n\n    SmartDashboard.putBoolean(\"Motor 1 Overcharged\", isOverCharged); //Logs overcharged state on the Dashboard\n</code></pre>"},{"location":"page3/#logging-multiple-mechanisms","title":"Logging multiple mechanisms","text":"<p>You can log detailed information for as many mechanisms as you want, lets log the current and boolean states of a 4 <code>MotorMonitor</code> Modules swerve Drivebase</p> <pre><code>    //Logs all the detailed information of the 4 Modules\n    double flcurrent = monitor1.getMotorcurrent();\n    boolean flstate = monitor1.isOvercharged(0);\n\n    double frcurrent = monitor2.getMotorcurrent();\n    boolean frstate = monitor2.isOvercharged(0);\n\n    double blcurrent = monitor3.getMotorcurrent();\n    boolean blstate = monitor3.isOvercharged(0);\n\n    double brcurrent = monitor4.getMotorcurrent();\n    boolean brstate = monitor4.isOvercharged(0);\n\n    //Group all this data into lists\n    Double[]SwerveCurrent = {flcurrent,frcurrent,blcurrent,brcurrent};\n\n    Boolean[]SwerveStates = {flstate,frstate,blstate,brstate};\n\n    //Display it \n    SmartDashboard.putNumberArray(\"SwerveCurrent\", SwerveCurrent);\n\n    SmartDashboard.putBooleanArray(\"ModulesOvercharged\", SwerveStates);\n</code></pre>"},{"location":"page4/","title":"Using Motor Monitor -Controlling Outputs","text":""},{"location":"page4/#controlling-the-max-output","title":"Controlling the MAX% Output","text":"<p><code>MotorMonitor</code> class counts with an static method: <code>setMaxOutputpercentage(double output, double %)</code>, this method allows us to  reduce the given output before sending to the motor by the % reprecenting how much percentage we want of the output (0-100) value.  This number is highly customisable and you can implemment it in different ways, lets see them:</p>"},{"location":"page4/#normal-reduction","title":"Normal % reduction","text":"<p>Here's a basic implementation of the method considering we have a motor <code>m_motor</code>:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    double outputPercentage = 85; // Only get the 85% of the value\n\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, outputPercentage)); //Move the motor with 85% of the axis\n</code></pre>"},{"location":"page4/#conditional-reduction","title":"Conditional reduction","text":"<p>Fine! but we can make simple conditions to trigger this reduction:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    double outputPercentage = 100; // get 100% of the value\n\n    //If the motor is overcharged, reduce the output by 30%\n    if (monitor1.isOvercharged(0)) { \n      outputPercentage = 70;\n    }\n\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, outputPercentage)); \n</code></pre> <p>Or we can trigger the reduction by a joystick button:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    double outputPercentage = 100; // get 100% of the value\n\n    //If the button is true, reduce the output by 30%\n    if (controller.getaButton()) { \n      outputPercentage = 70;\n    }\n\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, outputPercentage)); \n</code></pre> <p>Using the Driver's dashboard could be util too:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    double outputPercentage = 100; // get 100% of the value\n\n    boolean ShouldReduce = SmartDashboard.getBoolean(\"M1Reduction\", false); //Checks the value of the key \"M1Reduction\" returning false for default\n\n    //If \"M1Reduction\" is true, reduce the output by 30%\n    if (ShouldReduce) { \n      outputPercentage = 70;\n    }\n\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, outputPercentage)); \n</code></pre>"},{"location":"page4/#using-dashboard","title":"Using Dashboard","text":"<p>We can implement the <code>SmartDashboard</code> feature to tune more our reduction</p>"},{"location":"page4/#input-from-user","title":"Input from user","text":"<p>We can use the input given in the Dashboard to reduce our motors</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    double DashboardSet = SmartDashboard.getNumber(\"Motor1Output%\", 100); //Gets the number input from \"Motor1Output%\" (returning 100 if default)\n\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, DashboardSet)); //Sets the motor with the % output given by the Dashboard\n</code></pre>"},{"location":"page4/#sendablechooser","title":"SendableChooser","text":"<p>In addition, we can set 3 output % states and add it to a sendable chooser:</p> <ul> <li>MAX = 100% of the output</li> <li>MEDIUM = 85% of the output</li> <li>MIN = 70% of the output</li> </ul> <p>First, we need to create a <code>SendableChooser</code> object:</p> <pre><code>    //Creates a sendable chooser with the data type being double values\n    SendableChooser&lt;Double&gt; outputChooser = new SendableChooser&lt;&gt;();\n</code></pre> <p>Now we can define our 3 states in the code and send it to the output:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    //Set options for the Sendable Chooser with the default option being 100%\n    outputChooser.setDefaultOption(\"MAX\", 100.0);\n    outputChooser.addOption(\"MEDIUM\", 85.0);\n    outputChooser.addOption(\"MIN\", 70.0);\n\n    //Controlls the given output with the 3 states of the Sendable Chooser\n    m_motor.set(MotorMonitor.setMaxOutputpercentage(axis, outputChooser.getSelected()));\n</code></pre>"},{"location":"page5/","title":"Using Motor Monitor - WithSafety","text":"<p>Warning</p> <p>Before using the <code>withSafety(motorvalue)</code> method, make sure you already have configured the <code>MotorMonitor</code> and already have a  protocol</p> <p>Remember the configuration we set on Configuring the MotorMonitor ? With that configuration we can run a given output with the safety protocols without worrying of the overcurrent/states of the motor or manually setting up, the <code>withSafety(motorvalue)</code> method will do all that for you:</p> <p><code>withSafety(motorvalue)</code> Let the Monitor take actions based on high current levels or low battery voltage to preserve the motor conditions</p> <p>Parameters:</p> <p>motorvalue the output given to the motor</p> <p>Returns: the motor output with safety measurements</p>"},{"location":"page5/#implementation","title":"Implementation","text":"<p>Here's some basic implementation of how to run a motor with safety protocols:</p> <pre><code>    double axis = controller.getLeftY(); //get the value of the axis\n\n    m_motor.set(monitor1.withSafety(axis)); //Runs the motor with safety protocols enabled\n</code></pre>"},{"location":"page5/#disable","title":"Disable","text":"<p>It is as simpliest as you can see to run this method, also you can temporally disable the safety protocols if you are having issues:</p> <pre><code>    monitor1.disableSafety(true); //Disables the safety protocols of the motors\n</code></pre> <p>Or you can toggle the safety state on the dashboard like this:</p> <pre><code>    boolean getButton = SmartDashboard.getBoolean(\"ToggleSafety\", false); //Get the value of the key \"ToggleSafety\", returning false on default\n\n    monitor1.disableSafety(getButton); //Toggles the safety by the Dashboard\n</code></pre>"},{"location":"page6/","title":"Shutdown with Motor Monitor","text":"<p>During competition it is important to manage the state of the motors all through the match and being able to shutdown a motor is important for various reasons:</p> <ul> <li>Safety: A malfunctioning motor can pose significant risks, such as overheating, sparking, or causing damage to other components</li> <li>Preventing Further Damage: Running a motor with issues can lead to permanent damage, which could have been avoided by stopping it early. Continuing to operate a failing motor may also affect other systems, leading to a cascading failure within the robot</li> <li>Performance: A faulty motor can impair the robot's ability to perform effectively in the match. Shutting it down prevents erratic behavior that could affect game strategy</li> </ul>"},{"location":"page6/#shutdown-methods","title":"Shutdown Methods","text":"<p>To shutdown a motor, we need a motor running with the <code>withSafety(motorvalue)</code> method (guide here), we have the simple <code>forceShutDown()</code> method that we can call it, forcing the motor to shutdown</p> <pre><code>    monitor1.forceShutDown()//Shutdowns the motor\n</code></pre> <p>Also the <code>MotorMonitor</code> class provides a toggle method to shutdown the motor accepting a boolean value:</p> <pre><code>    monitor1.toggleShutdown(boolean);\n</code></pre> <p>We can do plenty of conditionals to trigger our toggle function, here are some examples:</p>"},{"location":"page6/#with-dashboard","title":"With Dashboard","text":"<pre><code>    boolean Shutdown = SmartDashboard.getBoolean(\"ShutdownMotor\", false);\n\n    monitor1.toggleShutdown(Shutdown);\n</code></pre>"},{"location":"page6/#with-joystickbutton","title":"With JoystickButton","text":"<pre><code>    boolean Shutdown = controller.getAButton();\n\n    monitor1.toggleShutdown(Shutdown);\n</code></pre>"},{"location":"page6/#with-sendable-chooser","title":"With sendable Chooser","text":"<pre><code>    SendableChooser&lt;Boolean&gt; shutdwon = new SendableChooser&lt;&gt;(); //Creates the sendable chooser\n</code></pre> <pre><code>    //adds options\n    shutdwon.setDefaultOption(\"SHUTDOWN: OFF\", false);\n    shutdwon.addOption(\"SHUTDOWN: ON\", true);\n\n    boolean Shutdown = shutdwon.getSelected(); //Selects the option\n\n    monitor1.toggleShutdown(Shutdown);\n</code></pre>"},{"location":"page6/#stalling-detection","title":"Stalling detection","text":"<p>When a motor stalls, it experiences maximum current draw while providing no output motion. This high current generates excessive heat, which can damage the motor's windings and even cause failures in the motor controller or other electrical components</p> <p>Keeping a stalled motor running could pose risks to the robot, the field, and team members, so it is important to shutdown inmediatelly</p> <p>Fortunately, the <code>MotorMonitor</code> class provides with a method that detects if a motor is stalled, combining this method with a shutdown method will protect the motor for any permanent damages</p> Method 1Method 2 <p>Checks if the Motor is stalled by passing the speed of the motor, forcing the motor to shutdown if true</p> <pre><code>if (monitor1.stallDetection(m_motor.get())) {\n  monitor1.forceShutDown();\n}\n</code></pre> <p>Checks if the Motor is stalled and inmediately disabling the motor if true</p> <pre><code>monitor1.toggleShutdown(monitor1.stallDetection(m_motor.get()));\n</code></pre> <p>As you can see, you can do a lot of triggers to the toggle method and also you can use conditionals with the forceShutdown method, it is up to you, your team needs and imagination</p>"}]}